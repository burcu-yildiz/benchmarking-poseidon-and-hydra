//Extended from https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom (commit: cff5ab6) 
pragma circom 2.0.0;

include "./my_poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[j][i]*in[j];
        }
        out[i] <== lc;
    }
}

template MixLast(t, M, s) {
    signal input in[t];
    signal output out;

    var lc = 0;
    for (var j=0; j<t; j++) {
        lc += M[j][s]*in[j];
    }
    out <== lc;
}

template MixS(t, S, r) {
    signal input in[t];
    signal output out[t];


    var lc = 0;
    for (var i=0; i<t; i++) {
        lc += S[(t*2-1)*r+i]*in[i];
    }
    out[0] <== lc;
    for (var i=1; i<t; i++) {
        out[i] <== in[i] +  in[0] * S[(t*2-1)*r + t + i -1];
    }
}

template PoseidonEx(nInputs, nOuts) {
    signal input inputs[nInputs];
    signal input initialState;
    signal output out[nOuts];

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2]; 
    var C[t*nRoundsF + nRoundsP] = POSEIDON_C(t);
    var S[  nRoundsP  *  (t*2-1)  ]  = POSEIDON_S(t);
    var M[t][t] = POSEIDON_M(t);
    var P[t][t] = POSEIDON_P(t);

    component ark[nRoundsF];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF-1];
    component mixS[nRoundsP];
    component mixLast[nOuts];


    ark[0] = Ark(t, C, 0);
    for (var j=0; j<t; j++) {
        if (j>0) {
            ark[0].in[j] <== inputs[j-1];
        } else {
            ark[0].in[j] <== initialState;
        }
    }

    //log("First round constants added",  ark[0].in[0], "became", ark[0].out[0], C[0]);

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[r][j] = Sigma();
            if(r==0) {
                sigmaF[r][j].in <== ark[0].out[j];
            } else {
                sigmaF[r][j].in <== mix[r-1].out[j];
            }
        }
        //log("Round", r, "sigmaF input", sigmaF[r][0].in, "output", sigmaF[r][0].out);

        ark[r+1] = Ark(t, C, (r+1)*t);
        for (var j=0; j<t; j++) {
            ark[r+1].in[j] <== sigmaF[r][j].out;
        }

        //log("Round", r, "ark input", ark[r+1].in[0], "output", ark[r+1].out[0]);


        mix[r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[r].in[j] <== ark[r+1].out[j];
        }
        //log("Round", r, "mix input", mix[r].in[0], "output", mix[r].out[0]);


    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF\2-1][j] = Sigma();
        sigmaF[nRoundsF\2-1][j].in <== mix[nRoundsF\2-2].out[j];
    }

    //log("After initial round last sbox", sigmaF[nRoundsF\2-1][0].out, sigmaF[nRoundsF\2-1][1].out, sigmaF[nRoundsF\2-1][2].out);

    ark[nRoundsF\2] = Ark(t, C, (nRoundsF\2)*t );
    for (var j=0; j<t; j++) {
        ark[nRoundsF\2].in[j] <== sigmaF[nRoundsF\2-1][j].out;
    }

    mix[nRoundsF\2-1] = Mix(t,P);
    for (var j=0; j<t; j++) {
        mix[nRoundsF\2-1].in[j] <== ark[nRoundsF\2].out[j];
    }


    for (var r = 0; r < nRoundsP; r++) {
        sigmaP[r] = Sigma();
        if (r==0) {
            sigmaP[r].in <== mix[nRoundsF\2-1].out[0];
        } else {
            sigmaP[r].in <== mixS[r-1].out[0];
        }

        mixS[r] = MixS(t, S, r);
        for (var j=0; j<t; j++) {
            if (j==0) {
                mixS[r].in[j] <== sigmaP[r].out + C[(nRoundsF\2+1)*t + r];
            } else {
                if (r==0) {
                    mixS[r].in[j] <== mix[nRoundsF\2-1].out[j];
                } else {
                    mixS[r].in[j] <== mixS[r-1].out[j];
                }
            }
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[nRoundsF\2 + r][j] = Sigma();
            if (r==0) {
                sigmaF[nRoundsF\2 + r][j].in <== mixS[nRoundsP-1].out[j];
            } else {
                sigmaF[nRoundsF\2 + r][j].in <== mix[nRoundsF\2+r-1].out[j];
            }
        }

        ark[ nRoundsF\2 + r + 1] = Ark(t, C,  (nRoundsF\2+1)*t + nRoundsP + r*t );
        for (var j=0; j<t; j++) {
            ark[nRoundsF\2 + r + 1].in[j] <== sigmaF[nRoundsF\2 + r][j].out;
        }

        mix[nRoundsF\2 + r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[nRoundsF\2 + r].in[j] <== ark[nRoundsF\2 + r + 1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF-1][j] = Sigma();
        sigmaF[nRoundsF-1][j].in <== mix[nRoundsF-2].out[j];
    }

    for (var i=0; i<nOuts; i++) {
        mixLast[i] = MixLast(t,M,i);
        for (var j=0; j<t; j++) {
            mixLast[i].in[j] <== sigmaF[nRoundsF-1][j].out;
        }
        out[i] <== mixLast[i].out;
    }

    //log("hashed", initialState, inputs[0], inputs[1], "to", out[0], out[1], out[2]);
}

template Poseidon(nInputs) {
    /*
    t (width) = nInputs
    capacity = 1. 80/128 bits collision resistance
    */
    signal input inputs[nInputs];
    signal output out;

    component pEx = PoseidonEx(nInputs, 1);
    pEx.initialState <== 0;
    for (var i=0; i<nInputs; i++) {
        pEx.inputs[i] <== inputs[i];
    }
    out <== pEx.out[0];
}

template Sponge(inputLength, rate, outLength) {
    signal input pt[inputLength];
    signal input initialState0;

    var initialState = initialState0;

    signal output ct[outLength];
    var padAmount = 0;
    if (rate != inputLength){
        padAmount = (rate - inputLength % rate) % rate;
    }
    var chunkCount = (padAmount + inputLength) / rate;
    log(chunkCount, rate, inputLength, padAmount);
    component Poseidons[chunkCount-1];
    var words[rate];
    for (var j=0; j<rate; j++) {
        words[j] = 0;
    }

    for (var i=0; i<chunkCount-1; i++) {
        log("chunk",i);
        for (var j=0; j<rate; j++) {
            words[j] = words[j] + pt[i*rate + j];
        }
        Poseidons[i] = PoseidonEx(rate, rate+1);
        Poseidons[i].initialState <== initialState;
        for (var j=0; j<rate; j++) {
            Poseidons[i].inputs[j] <== words[j];               
        }
        initialState = Poseidons[i].out[0];       
        for (var j=0; j<rate; j++) {
            words[j] = Poseidons[i].out[j+1];          
        }
    }

    for (var j=0; j<rate; j++) {
        words[j] = words[j] + pt[(chunkCount-1)*rate + j];       
    }
    var lastBound = outLength % rate; 
    if (outLength % rate == 0) {
        lastBound = rate;
    } 
    
    chunkCount = (outLength - lastBound) / rate + 1;
    
    component OutputPoseidons[chunkCount];    

    for (var i=0; i<chunkCount-1; i++) {
        OutputPoseidons[i] = PoseidonEx(rate, rate+1);
        for (var j=0; j<rate; j++) {
            OutputPoseidons[i].inputs[j] <== words[j];               
        }
        OutputPoseidons[i].initialState <== initialState;
        initialState = OutputPoseidons[i].out[0];       
        for (var j=0; j<rate; j++) {
            words[j] = OutputPoseidons[i].out[j+1];             
            ct[i*rate+j] <== words[j];     
        }
    }

    OutputPoseidons[chunkCount-1] = PoseidonEx(rate, lastBound);
    OutputPoseidons[chunkCount-1].initialState <== initialState;

    for (var j=0; j<rate; j++) {
        OutputPoseidons[chunkCount-1].inputs[j] <== words[j];               
    }
    for (var j=0; j<lastBound; j++) {
        ct[j+rate*(chunkCount-1)] <== OutputPoseidons[chunkCount-1].out[j];
    }
}

template Encrypt(ptLength, t, rate) {
    assert(rate<=t);
    signal input pt[ptLength];
    ///key length should be t
    signal input key[t-1]; 

    signal input initialState0;
    var nonce = initialState0;
    
    signal output ct[ptLength+2];

    var padAmount = rate - ptLength % rate;
    if (ptLength % rate == 0) {
        padAmount = 0;
    }
    var chunkCount = (padAmount + ptLength) / rate;

    component Poseidons[chunkCount];
    var words[t];
    for (var i=0; i<t-1;i++) {
        words[i+1] = key[i];
    }
    words[0] =  nonce;

    
    for (var i=0; i<chunkCount-1; i++) {
        log("chunk",i);
        Poseidons[i] = PoseidonEx(rate, t);
        Poseidons[i].initialState <== words[0];
        
        for (var j=1; j<t; j++) {
            Poseidons[i].inputs[j-1] <== words[j];               
        }
        words = Poseidons[i].out;
        for (var j=0; j<rate; j++) {
            words[j] += pt[i*rate+j];   
            ct[i*rate+j] <== words[j];
        }
    }

    Poseidons[chunkCount-1] = PoseidonEx(rate, t);
    Poseidons[chunkCount-1].initialState <== words[0];

    for (var j=1; j<t; j++) {
        Poseidons[chunkCount-1].inputs[j-1] <== words[j];               
    }
    words = Poseidons[chunkCount-1].out;
    for (var j=0; j<rate-padAmount; j++) {
        words[j] += pt[(chunkCount-1)*rate+j];   
        ct[(chunkCount-1)*rate+j] <== words[j];
    }

    component macPoseidon = PoseidonEx(rate,1);
    ct[ptLength] <== nonce;
    for (var i=0; i<rate;i++) {
        macPoseidon.inputs[i] <== words[i+1];
    }
    macPoseidon.initialState <== words[0];
    ct[ptLength+1] <== macPoseidon.out[0];
    //log(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5], ct[6], ct[7], ct[8], ct[9]);
}

template hashMain() {
    signal input inputs[2];
    signal input initialState;
    signal output out[1];

    component pEx = PoseidonEx(2, 1);
    pEx.initialState <== initialState;
    for (var i=0; i<2; i++) {
        pEx.inputs[i] <== inputs[i];
    }
    out <== pEx.out;
}

//for encryption run: Encrypt(plaintext length, t, rate), where only t=rate+1 is supported
//for hash run: Sponge(input length, rate, output length)
component main {public [initialState0]} = Encrypt(8,3,2);//Sponge(4,4,16);